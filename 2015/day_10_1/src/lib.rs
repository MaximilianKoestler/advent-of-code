/// Transforms a string of digits into the corresponding "look and say" sequence.
/// A look-and-say sequence is generated by reading the digits of the previous sequence aloud.
#[must_use]
pub fn look_and_say(input: &str) -> String {
    input
        .chars()
        .map(Some)
        .chain(std::iter::once(None))
        .fold(
            (String::new(), None, 0),
            |(mut acc, mut previous, mut count), current| {
                match (previous, current) {
                    (None, _) => {
                        count = 1;
                    }
                    (Some(prev), Some(current)) if prev == current => {
                        count += 1;
                    }
                    (Some(prev), _) => {
                        acc.push_str(&count.to_string());
                        acc.push(prev);
                        count = 1;
                    }
                }
                previous = current;
                (acc, previous, count)
            },
        )
        .0
}

#[must_use]
pub fn repeat_look_and_say(input: &str, times: usize) -> String {
    (0..times).fold(input.to_string(), |acc, _| look_and_say(&acc))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_look_and_say() {
        assert_eq!(look_and_say("1"), "11");
        assert_eq!(look_and_say("11"), "21");
        assert_eq!(look_and_say("21"), "1211");
        assert_eq!(look_and_say("1211"), "111221");
        assert_eq!(look_and_say("111221"), "312211");
    }

    #[test]
    fn test_repeat_fold() {
        assert_eq!(repeat_look_and_say("1", 5), "312211");
    }
}
